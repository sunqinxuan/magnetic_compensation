\hypertarget{_tensor_forward_declarations_8h}{}\doxysection{3rd\+\_\+party/eigen-\/3.3.9/unsupported/\+Eigen/\+C\+X\+X11/src/\+Tensor/\+Tensor\+Forward\+Declarations.h File Reference}
\label{_tensor_forward_declarations_8h}\index{3rd\_party/eigen-\/3.3.9/unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h@{3rd\_party/eigen-\/3.3.9/unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h}}
\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{struct_eigen_1_1_make_pointer}{Eigen\+::\+Make\+Pointer$<$ T $>$}}
\item 
class \mbox{\hyperlink{class_eigen_1_1_tensor_map}{Eigen\+::\+Tensor\+Map}}
\begin{DoxyCompactList}\small\item\em A tensor expression mapping an existing array of data. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_eigen_1_1_tensor}{Eigen\+::\+Tensor$<$ Scalar\+\_\+, Num\+Indices\+\_\+, Options\+\_\+, Index\+Type\+\_\+ $>$}}
\begin{DoxyCompactList}\small\item\em The tensor class. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_eigen_1_1_tensor_fixed_size}{Eigen\+::\+Tensor\+Fixed\+Size$<$ Scalar\+\_\+, Dimensions\+\_\+, Options\+\_\+, Index\+Type $>$}}
\begin{DoxyCompactList}\small\item\em The fixed sized version of the tensor class. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_eigen_1_1_tensor_ref}{Eigen\+::\+Tensor\+Ref}}
\begin{DoxyCompactList}\small\item\em A reference to a tensor expression The expression will be evaluated lazily (as much as possible). \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_eigen_1_1_tensor_base}{Eigen\+::\+Tensor\+Base$<$ Derived, Access\+Level $>$}}
\begin{DoxyCompactList}\small\item\em The tensor base class. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_eigen_1_1_tensor_cwise_nullary_op}{Eigen\+::\+Tensor\+Cwise\+Nullary\+Op$<$ Nullary\+Op, Xpr\+Type $>$}}
\item 
class \mbox{\hyperlink{class_eigen_1_1_tensor_cwise_unary_op}{Eigen\+::\+Tensor\+Cwise\+Unary\+Op$<$ Unary\+Op, Xpr\+Type $>$}}
\item 
class \mbox{\hyperlink{class_eigen_1_1_tensor_cwise_binary_op}{Eigen\+::\+Tensor\+Cwise\+Binary\+Op$<$ Binary\+Op, Lhs\+Xpr\+Type, Rhs\+Xpr\+Type $>$}}
\item 
class \mbox{\hyperlink{class_eigen_1_1_tensor_cwise_ternary_op}{Eigen\+::\+Tensor\+Cwise\+Ternary\+Op$<$ Ternary\+Op, Arg1\+Xpr\+Type, Arg2\+Xpr\+Type, Arg3\+Xpr\+Type $>$}}
\item 
class \mbox{\hyperlink{class_eigen_1_1_tensor_select_op}{Eigen\+::\+Tensor\+Select\+Op$<$ If\+Xpr\+Type, Then\+Xpr\+Type, Else\+Xpr\+Type $>$}}
\item 
class \mbox{\hyperlink{class_eigen_1_1_tensor_reduction_op}{Eigen\+::\+Tensor\+Reduction\+Op$<$ Op, Dims, Xpr\+Type, Make\+Pointer\+\_\+ $>$}}
\item 
class \mbox{\hyperlink{class_eigen_1_1_tensor_index_tuple_op}{Eigen\+::\+Tensor\+Index\+Tuple\+Op$<$ Xpr\+Type $>$}}
\item 
class \mbox{\hyperlink{class_eigen_1_1_tensor_tuple_reducer_op}{Eigen\+::\+Tensor\+Tuple\+Reducer\+Op$<$ Reduce\+Op, Dims, Xpr\+Type $>$}}
\item 
class \mbox{\hyperlink{class_eigen_1_1_tensor_concatenation_op}{Eigen\+::\+Tensor\+Concatenation\+Op$<$ Axis, Lhs\+Xpr\+Type, Rhs\+Xpr\+Type $>$}}
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{class_eigen_1_1_tensor}{Tensor}} concatenation class. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_eigen_1_1_tensor_contraction_op}{Eigen\+::\+Tensor\+Contraction\+Op$<$ Indices, Lhs\+Xpr\+Type, Rhs\+Xpr\+Type $>$}}
\item 
class \mbox{\hyperlink{class_eigen_1_1_tensor_conversion_op}{Eigen\+::\+Tensor\+Conversion\+Op$<$ Target\+Type, Xpr\+Type $>$}}
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{class_eigen_1_1_tensor}{Tensor}} conversion class. This class makes it possible to vectorize type casting operations when the number of scalars per packet in the source and the destination type differ. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_eigen_1_1_tensor_convolution_op}{Eigen\+::\+Tensor\+Convolution\+Op$<$ Indices, Input\+Xpr\+Type, Kernel\+Xpr\+Type $>$}}
\item 
class \mbox{\hyperlink{class_eigen_1_1_tensor_f_f_t_op}{Eigen\+::\+Tensor\+F\+F\+T\+Op$<$ F\+F\+T, Xpr\+Type, F\+F\+T\+Data\+Type, F\+F\+T\+Direction $>$}}
\item 
class \mbox{\hyperlink{class_eigen_1_1_tensor_patch_op}{Eigen\+::\+Tensor\+Patch\+Op$<$ Patch\+Dim, Xpr\+Type $>$}}
\item 
class \mbox{\hyperlink{class_eigen_1_1_tensor_image_patch_op}{Eigen\+::\+Tensor\+Image\+Patch\+Op$<$ Rows, Cols, Xpr\+Type $>$}}
\item 
class \mbox{\hyperlink{class_eigen_1_1_tensor_volume_patch_op}{Eigen\+::\+Tensor\+Volume\+Patch\+Op$<$ Planes, Rows, Cols, Xpr\+Type $>$}}
\item 
class \mbox{\hyperlink{class_eigen_1_1_tensor_broadcasting_op}{Eigen\+::\+Tensor\+Broadcasting\+Op$<$ Broadcast, Xpr\+Type $>$}}
\item 
class \mbox{\hyperlink{class_eigen_1_1_tensor_chipping_op}{Eigen\+::\+Tensor\+Chipping\+Op$<$ Dim\+Id, Xpr\+Type $>$}}
\item 
class \mbox{\hyperlink{class_eigen_1_1_tensor_reshaping_op}{Eigen\+::\+Tensor\+Reshaping\+Op$<$ New\+Dimensions, Xpr\+Type $>$}}
\item 
class \mbox{\hyperlink{class_eigen_1_1_tensor_layout_swap_op}{Eigen\+::\+Tensor\+Layout\+Swap\+Op$<$ Xpr\+Type $>$}}
\item 
class \mbox{\hyperlink{class_eigen_1_1_tensor_slicing_op}{Eigen\+::\+Tensor\+Slicing\+Op$<$ Start\+Indices, Sizes, Xpr\+Type $>$}}
\item 
class \mbox{\hyperlink{class_eigen_1_1_tensor_reverse_op}{Eigen\+::\+Tensor\+Reverse\+Op$<$ Reverse\+Dimensions, Xpr\+Type $>$}}
\item 
class \mbox{\hyperlink{class_eigen_1_1_tensor_padding_op}{Eigen\+::\+Tensor\+Padding\+Op$<$ Padding\+Dimensions, Xpr\+Type $>$}}
\item 
class \mbox{\hyperlink{class_eigen_1_1_tensor_shuffling_op}{Eigen\+::\+Tensor\+Shuffling\+Op$<$ Shuffle, Xpr\+Type $>$}}
\item 
class \mbox{\hyperlink{class_eigen_1_1_tensor_striding_op}{Eigen\+::\+Tensor\+Striding\+Op$<$ Strides, Xpr\+Type $>$}}
\item 
class \mbox{\hyperlink{class_eigen_1_1_tensor_striding_slicing_op}{Eigen\+::\+Tensor\+Striding\+Slicing\+Op$<$ Start\+Indices, Stop\+Indices, Strides, Xpr\+Type $>$}}
\item 
class \mbox{\hyperlink{class_eigen_1_1_tensor_inflation_op}{Eigen\+::\+Tensor\+Inflation\+Op$<$ Strides, Xpr\+Type $>$}}
\item 
class \mbox{\hyperlink{class_eigen_1_1_tensor_generator_op}{Eigen\+::\+Tensor\+Generator\+Op}}
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{class_eigen_1_1_tensor}{Tensor}} generator class. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_eigen_1_1_tensor_assign_op}{Eigen\+::\+Tensor\+Assign\+Op$<$ Lhs\+Xpr\+Type, Rhs\+Xpr\+Type $>$}}
\item 
class \mbox{\hyperlink{class_eigen_1_1_tensor_scan_op}{Eigen\+::\+Tensor\+Scan\+Op$<$ Op, Xpr\+Type $>$}}
\item 
class \mbox{\hyperlink{class_eigen_1_1_tensor_custom_unary_op}{Eigen\+::\+Tensor\+Custom\+Unary\+Op$<$ Custom\+Unary\+Func, Xpr\+Type $>$}}
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{class_eigen_1_1_tensor}{Tensor}} custom class. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_eigen_1_1_tensor_custom_binary_op}{Eigen\+::\+Tensor\+Custom\+Binary\+Op$<$ Custom\+Binary\+Func, Lhs\+Xpr\+Type, Rhs\+Xpr\+Type $>$}}
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{class_eigen_1_1_tensor}{Tensor}} custom class. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_eigen_1_1_tensor_eval_to_op}{Eigen\+::\+Tensor\+Eval\+To\+Op$<$ Xpr\+Type, Make\+Pointer\+\_\+ $>$}}
\item 
class \mbox{\hyperlink{class_eigen_1_1_tensor_forced_eval_op}{Eigen\+::\+Tensor\+Forced\+Eval\+Op$<$ Xpr\+Type, Make\+Pointer\+\_\+ $>$}}
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{class_eigen_1_1_tensor}{Tensor}} reshaping class. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_eigen_1_1_tensor_device}{Eigen\+::\+Tensor\+Device$<$ Expression\+Type, Device\+Type $>$}}
\begin{DoxyCompactList}\small\item\em Pseudo expression providing an operator = that will evaluate its argument on the specified computing \textquotesingle{}device\textquotesingle{} (G\+PU, thread pool, ...) \end{DoxyCompactList}\item 
class \mbox{\hyperlink{struct_eigen_1_1_tensor_evaluator}{Eigen\+::\+Tensor\+Evaluator$<$ Derived, Device $>$}}
\begin{DoxyCompactList}\small\item\em A cost model used to limit the number of threads used for evaluating tensor expression. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{struct_eigen_1_1internal_1_1_is_vectorizable}{Eigen\+::internal\+::\+Is\+Vectorizable$<$ Device, Expression $>$}}
\item 
struct \mbox{\hyperlink{struct_eigen_1_1internal_1_1_is_vectorizable_3_01_gpu_device_00_01_expression_01_4}{Eigen\+::internal\+::\+Is\+Vectorizable$<$ Gpu\+Device, Expression $>$}}
\item 
class \mbox{\hyperlink{class_eigen_1_1internal_1_1_tensor_executor}{Eigen\+::internal\+::\+Tensor\+Executor$<$ Expression, Device, Vectorizable $>$}}
\end{DoxyCompactItemize}
\doxysubsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
 \mbox{\hyperlink{namespace_eigen}{Eigen}}
\item 
 \mbox{\hyperlink{namespace_eigen_1_1internal}{Eigen\+::internal}}
\end{DoxyCompactItemize}
\doxysubsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum \mbox{\hyperlink{namespace_eigen_a5c51628ff1971f45d37282fedc8cdafe}{Eigen\+::\+F\+F\+T\+Result\+Type}} \{ \mbox{\hyperlink{namespace_eigen_a5c51628ff1971f45d37282fedc8cdafeaf2d57ba74eb1535af45010eeaa70ed0a}{Eigen\+::\+Real\+Part}} = 0, 
\mbox{\hyperlink{namespace_eigen_a5c51628ff1971f45d37282fedc8cdafeab3cc7334ae85776014eae0f3ae1d4b76}{Eigen\+::\+Imag\+Part}} = 1, 
\mbox{\hyperlink{namespace_eigen_a5c51628ff1971f45d37282fedc8cdafeacd32c292b6cc73c96eb592ca3a779daf}{Eigen\+::\+Both\+Parts}} = 2
 \}
\item 
enum \mbox{\hyperlink{namespace_eigen_a21243f618445aca2fd04fd6a0f0f6bf6}{Eigen\+::\+F\+F\+T\+Direction}} \{ \mbox{\hyperlink{namespace_eigen_a21243f618445aca2fd04fd6a0f0f6bf6a61760ed615a5006b7b20b28da7e3c0ec}{Eigen\+::\+F\+F\+T\+\_\+\+F\+O\+R\+W\+A\+RD}} = 0, 
\mbox{\hyperlink{namespace_eigen_a21243f618445aca2fd04fd6a0f0f6bf6a73ecf68b9c0689f7d604572d7b1d3b50}{Eigen\+::\+F\+F\+T\+\_\+\+R\+E\+V\+E\+R\+SE}} = 1
 \}
\end{DoxyCompactItemize}
