\hypertarget{namespaceutility_1_1tuple}{}\doxysection{utility\+::tuple Namespace Reference}
\label{namespaceutility_1_1tuple}\index{utility::tuple@{utility::tuple}}
\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{structutility_1_1tuple_1_1_elem_type_holder}{Elem\+Type\+Holder}}
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{structutility_1_1tuple_1_1_elem_type_holder}{Elem\+Type\+Holder}} class is used to specify the types of the elements inside the tuple. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structutility_1_1tuple_1_1_elem_type_holder_3_010_00_01_tuple_3_01_t_00_01_ts_8_8_8_01_4_01_4}{Elem\+Type\+Holder$<$ 0, Tuple$<$ T, Ts... $>$ $>$}}
\begin{DoxyCompactList}\small\item\em specialisation of the \mbox{\hyperlink{structutility_1_1tuple_1_1_elem_type_holder}{Elem\+Type\+Holder}} class when the number of elements inside the tuple is 1 \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structutility_1_1tuple_1_1_elem_type_holder_3_01k_00_01_tuple_3_01_t_00_01_ts_8_8_8_01_4_01_4}{Elem\+Type\+Holder$<$ k, Tuple$<$ T, Ts... $>$ $>$}}
\begin{DoxyCompactList}\small\item\em specialisation of the \mbox{\hyperlink{structutility_1_1tuple_1_1_elem_type_holder}{Elem\+Type\+Holder}} class when the number of elements inside the tuple is bigger than 1. It recursively calls itself to detect the type of each element in the tuple \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structutility_1_1tuple_1_1_index_list}{Index\+List}}
\begin{DoxyCompactList}\small\item\em Creates a list of index from the elements in the tuple. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structutility_1_1tuple_1_1_index_range}{Index\+Range}}
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{structutility_1_1tuple_1_1_index_range}{Index\+Range}} that returns a \mbox{[}M\+IN, M\+AX) index range. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structutility_1_1tuple_1_1_range_builder}{Range\+Builder}}
\begin{DoxyCompactList}\small\item\em Collects internal details for generating index ranges \mbox{[}M\+IN, M\+AX) Declare primary template for index range builder. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structutility_1_1tuple_1_1_range_builder_3_01_m_i_n_00_01_m_i_n_00_01_is_8_8_8_01_4}{Range\+Builder$<$ M\+I\+N, M\+I\+N, Is... $>$}}
\begin{DoxyCompactList}\small\item\em base Step\+: Specialisation of the \mbox{\hyperlink{structutility_1_1tuple_1_1_range_builder}{Range\+Builder}} when the M\+IN==M\+AX. In this case the Is... is \mbox{[}0 to sizeof...(tuple elements)) \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structutility_1_1tuple_1_1_static_if}{Static\+If}}
\begin{DoxyCompactList}\small\item\em The \mbox{\hyperlink{structutility_1_1tuple_1_1_static_if}{Static\+If}} struct is used to statically choose the type based on the condition. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structutility_1_1tuple_1_1_static_if_3_01true_00_01_t_01_4}{Static\+If$<$ true, T $>$}}
\begin{DoxyCompactList}\small\item\em specialisation of the \mbox{\hyperlink{structutility_1_1tuple_1_1_static_if}{Static\+If}} when the condition is true \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structutility_1_1tuple_1_1_tuple}{Tuple}}
\begin{DoxyCompactList}\small\item\em is a fixed-\/size collection of heterogeneous values \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structutility_1_1tuple_1_1_tuple_3_01_t_00_01_ts_8_8_8_01_4}{Tuple$<$ T, Ts... $>$}}
\begin{DoxyCompactList}\small\item\em specialisation of the \mbox{\hyperlink{structutility_1_1tuple_1_1_tuple}{Tuple}} class when the tuple has at least one element. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename... Args$>$ }\\\mbox{\hyperlink{structutility_1_1tuple_1_1_tuple}{Tuple}}$<$ Args... $>$ \mbox{\hyperlink{namespaceutility_1_1tuple_aa68638ef30be12f1bcc6ef5da635c744}{make\+\_\+tuple}} (Args... args)
\begin{DoxyCompactList}\small\item\em Creates a tuple object, deducing the target type from the types of arguments. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename... Args, typename T , size\+\_\+t... I$>$ }\\\mbox{\hyperlink{structutility_1_1tuple_1_1_tuple}{Tuple}}$<$ Args..., T $>$ \mbox{\hyperlink{namespaceutility_1_1tuple_a446670118f4f4b05503c4e0b41dae565}{append\+\_\+base}} (\mbox{\hyperlink{structutility_1_1tuple_1_1_tuple}{Tuple}}$<$ Args... $>$ t, T a, \mbox{\hyperlink{structutility_1_1tuple_1_1_index_list}{Index\+List}}$<$ I... $>$)
\begin{DoxyCompactList}\small\item\em unpacking the elements of the input tuple t and creating a new tuple by adding element a at the end of it. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename... Args, typename T $>$ }\\\mbox{\hyperlink{structutility_1_1tuple_1_1_tuple}{Tuple}}$<$ Args..., T $>$ \mbox{\hyperlink{namespaceutility_1_1tuple_aeb1d9564d8270778d3b964c1bbc97345}{append}} (\mbox{\hyperlink{structutility_1_1tuple_1_1_tuple}{Tuple}}$<$ Args... $>$ t, T a)
\begin{DoxyCompactList}\small\item\em the deduction function for \mbox{\hyperlink{namespaceutility_1_1tuple_a446670118f4f4b05503c4e0b41dae565}{append\+\_\+base}} that automatically generate the \mbox{\hyperlink{structutility_1_1tuple_1_1_index_range}{Index\+Range}} \end{DoxyCompactList}\item 
{\footnotesize template$<$typename... Args1, typename... Args2, size\+\_\+t... I1, size\+\_\+t... I2$>$ }\\\mbox{\hyperlink{structutility_1_1tuple_1_1_tuple}{Tuple}}$<$ Args1..., Args2... $>$ \mbox{\hyperlink{namespaceutility_1_1tuple_ae5bb1d6f355eb022f06581fb8d02b3a1}{append\+\_\+base}} (\mbox{\hyperlink{structutility_1_1tuple_1_1_tuple}{Tuple}}$<$ Args1... $>$ t1, \mbox{\hyperlink{structutility_1_1tuple_1_1_tuple}{Tuple}}$<$ Args2... $>$ t2, \mbox{\hyperlink{structutility_1_1tuple_1_1_index_list}{Index\+List}}$<$ I1... $>$, \mbox{\hyperlink{structutility_1_1tuple_1_1_index_list}{Index\+List}}$<$ I2... $>$)
\begin{DoxyCompactList}\small\item\em This is a specialisation of \mbox{\hyperlink{namespaceutility_1_1tuple_a446670118f4f4b05503c4e0b41dae565}{append\+\_\+base}} when we want to concatenate tuple t2 at the end of the tuple t1. Here we unpack both tuples, generate the \mbox{\hyperlink{structutility_1_1tuple_1_1_index_range}{Index\+Range}} for each of them and create an output tuple T that contains both elements of t1 and t2. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename... Args1, typename... Args2$>$ }\\\mbox{\hyperlink{structutility_1_1tuple_1_1_tuple}{Tuple}}$<$ Args1..., Args2... $>$ \mbox{\hyperlink{namespaceutility_1_1tuple_a962fd93fb21129491975d3c4807fdad1}{append}} (\mbox{\hyperlink{structutility_1_1tuple_1_1_tuple}{Tuple}}$<$ Args1... $>$ t1, \mbox{\hyperlink{structutility_1_1tuple_1_1_tuple}{Tuple}}$<$ Args2... $>$ t2)
\begin{DoxyCompactList}\small\item\em deduction function for \mbox{\hyperlink{namespaceutility_1_1tuple_a446670118f4f4b05503c4e0b41dae565}{append\+\_\+base}} when we are appending tuple t1 by tuple t2. In this case the \mbox{\hyperlink{structutility_1_1tuple_1_1_index_range}{Index\+Range}} for both tuple are automatically generated. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Function Documentation}
\mbox{\Hypertarget{namespaceutility_1_1tuple_aeb1d9564d8270778d3b964c1bbc97345}\label{namespaceutility_1_1tuple_aeb1d9564d8270778d3b964c1bbc97345}} 
\index{utility::tuple@{utility::tuple}!append@{append}}
\index{append@{append}!utility::tuple@{utility::tuple}}
\doxysubsubsection{\texorpdfstring{append()}{append()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename... Args, typename T $>$ \\
\mbox{\hyperlink{structutility_1_1tuple_1_1_tuple}{Tuple}}$<$Args..., T$>$ utility\+::tuple\+::append (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structutility_1_1tuple_1_1_tuple}{Tuple}}$<$ Args... $>$}]{t,  }\item[{T}]{a }\end{DoxyParamCaption})}



the deduction function for \mbox{\hyperlink{namespaceutility_1_1tuple_a446670118f4f4b05503c4e0b41dae565}{append\+\_\+base}} that automatically generate the \mbox{\hyperlink{structutility_1_1tuple_1_1_index_range}{Index\+Range}} 

append 
\begin{DoxyTemplParams}{Template Parameters}
{\em Args...} & the type of the elements inside the tuple t \\
\hline
{\em T} & the type of the new element going to be added at the end of tuple \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em t} & the tuple on which we want to append a. \\
\hline
{\em a} & the new elements going to be added to the tuple \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Tuple$<$\+Args..., T$>$ 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceutility_1_1tuple_a962fd93fb21129491975d3c4807fdad1}\label{namespaceutility_1_1tuple_a962fd93fb21129491975d3c4807fdad1}} 
\index{utility::tuple@{utility::tuple}!append@{append}}
\index{append@{append}!utility::tuple@{utility::tuple}}
\doxysubsubsection{\texorpdfstring{append()}{append()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename... Args1, typename... Args2$>$ \\
\mbox{\hyperlink{structutility_1_1tuple_1_1_tuple}{Tuple}}$<$Args1..., Args2...$>$ utility\+::tuple\+::append (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structutility_1_1tuple_1_1_tuple}{Tuple}}$<$ Args1... $>$}]{t1,  }\item[{\mbox{\hyperlink{structutility_1_1tuple_1_1_tuple}{Tuple}}$<$ Args2... $>$}]{t2 }\end{DoxyParamCaption})}



deduction function for \mbox{\hyperlink{namespaceutility_1_1tuple_a446670118f4f4b05503c4e0b41dae565}{append\+\_\+base}} when we are appending tuple t1 by tuple t2. In this case the \mbox{\hyperlink{structutility_1_1tuple_1_1_index_range}{Index\+Range}} for both tuple are automatically generated. 

append 
\begin{DoxyTemplParams}{Template Parameters}
{\em Args1...} & the type of the elements inside the tuple t1 \\
\hline
{\em Args2...} & the type of the elements inside the tuple t2 \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em t1} & is the tuple on which we want to append t2. \\
\hline
{\em t2} & is the tuple that is going to be added on t1. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Tuple$<$\+Args1..., Args2...$>$ 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceutility_1_1tuple_a446670118f4f4b05503c4e0b41dae565}\label{namespaceutility_1_1tuple_a446670118f4f4b05503c4e0b41dae565}} 
\index{utility::tuple@{utility::tuple}!append\_base@{append\_base}}
\index{append\_base@{append\_base}!utility::tuple@{utility::tuple}}
\doxysubsubsection{\texorpdfstring{append\_base()}{append\_base()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename... Args, typename T , size\+\_\+t... I$>$ \\
\mbox{\hyperlink{structutility_1_1tuple_1_1_tuple}{Tuple}}$<$Args..., T$>$ utility\+::tuple\+::append\+\_\+base (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structutility_1_1tuple_1_1_tuple}{Tuple}}$<$ Args... $>$}]{t,  }\item[{T}]{a,  }\item[{\mbox{\hyperlink{structutility_1_1tuple_1_1_index_list}{Index\+List}}$<$ I... $>$}]{ }\end{DoxyParamCaption})}



unpacking the elements of the input tuple t and creating a new tuple by adding element a at the end of it. 

append\+\_\+base 
\begin{DoxyTemplParams}{Template Parameters}
{\em Args...} & the type of the elements inside the tuple t \\
\hline
{\em T} & the type of the new element going to be added at the end of tuple \\
\hline
{\em I...} & is the list of index from \mbox{[}0 to sizeof...(t)) \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em t} & the tuple on which we want to append a. \\
\hline
{\em a} & the new elements going to be added to the tuple \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Tuple$<$\+Args..., T$>$ 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceutility_1_1tuple_ae5bb1d6f355eb022f06581fb8d02b3a1}\label{namespaceutility_1_1tuple_ae5bb1d6f355eb022f06581fb8d02b3a1}} 
\index{utility::tuple@{utility::tuple}!append\_base@{append\_base}}
\index{append\_base@{append\_base}!utility::tuple@{utility::tuple}}
\doxysubsubsection{\texorpdfstring{append\_base()}{append\_base()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename... Args1, typename... Args2, size\+\_\+t... I1, size\+\_\+t... I2$>$ \\
\mbox{\hyperlink{structutility_1_1tuple_1_1_tuple}{Tuple}}$<$Args1..., Args2...$>$ utility\+::tuple\+::append\+\_\+base (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structutility_1_1tuple_1_1_tuple}{Tuple}}$<$ Args1... $>$}]{t1,  }\item[{\mbox{\hyperlink{structutility_1_1tuple_1_1_tuple}{Tuple}}$<$ Args2... $>$}]{t2,  }\item[{\mbox{\hyperlink{structutility_1_1tuple_1_1_index_list}{Index\+List}}$<$ I1... $>$}]{,  }\item[{\mbox{\hyperlink{structutility_1_1tuple_1_1_index_list}{Index\+List}}$<$ I2... $>$}]{ }\end{DoxyParamCaption})}



This is a specialisation of \mbox{\hyperlink{namespaceutility_1_1tuple_a446670118f4f4b05503c4e0b41dae565}{append\+\_\+base}} when we want to concatenate tuple t2 at the end of the tuple t1. Here we unpack both tuples, generate the \mbox{\hyperlink{structutility_1_1tuple_1_1_index_range}{Index\+Range}} for each of them and create an output tuple T that contains both elements of t1 and t2. 

append\+\_\+base 
\begin{DoxyTemplParams}{Template Parameters}
{\em Args1...} & the type of the elements inside the tuple t1 \\
\hline
{\em Args2...} & the type of the elements inside the tuple t2 \\
\hline
{\em I1...} & is the list of index from \mbox{[}0 to sizeof...(t1)) \\
\hline
{\em I2...} & is the list of index from \mbox{[}0 to sizeof...(t2)) \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em t1} & is the tuple on which we want to append t2. \\
\hline
{\em t2} & is the tuple that is going to be added on t1. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Tuple$<$\+Args1..., Args2...$>$ 
\end{DoxyReturn}
\mbox{\Hypertarget{namespaceutility_1_1tuple_aa68638ef30be12f1bcc6ef5da635c744}\label{namespaceutility_1_1tuple_aa68638ef30be12f1bcc6ef5da635c744}} 
\index{utility::tuple@{utility::tuple}!make\_tuple@{make\_tuple}}
\index{make\_tuple@{make\_tuple}!utility::tuple@{utility::tuple}}
\doxysubsubsection{\texorpdfstring{make\_tuple()}{make\_tuple()}}
{\footnotesize\ttfamily template$<$typename... Args$>$ \\
\mbox{\hyperlink{structutility_1_1tuple_1_1_tuple}{Tuple}}$<$Args...$>$ utility\+::tuple\+::make\+\_\+tuple (\begin{DoxyParamCaption}\item[{Args...}]{args }\end{DoxyParamCaption})}



Creates a tuple object, deducing the target type from the types of arguments. 

make\+\_\+tuple 
\begin{DoxyTemplParams}{Template Parameters}
{\em Args} & the type of the arguments to construct the tuple from \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em args} & zero or more arguments to construct the tuple from \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Tuple$<$\+Args...$>$ 
\end{DoxyReturn}
