\hypertarget{_tensor_sycl_tuple_8h}{}\doxysection{3rd\+\_\+party/eigen-\/3.3.9/unsupported/\+Eigen/\+C\+X\+X11/src/\+Tensor/\+Tensor\+Sycl\+Tuple.h File Reference}
\label{_tensor_sycl_tuple_8h}\index{3rd\_party/eigen-\/3.3.9/unsupported/Eigen/CXX11/src/Tensor/TensorSyclTuple.h@{3rd\_party/eigen-\/3.3.9/unsupported/Eigen/CXX11/src/Tensor/TensorSyclTuple.h}}
\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{structutility_1_1tuple_1_1_static_if}{utility\+::tuple\+::\+Static\+If}}
\begin{DoxyCompactList}\small\item\em The \mbox{\hyperlink{structutility_1_1tuple_1_1_static_if}{Static\+If}} struct is used to statically choose the type based on the condition. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structutility_1_1tuple_1_1_static_if_3_01true_00_01_t_01_4}{utility\+::tuple\+::\+Static\+If$<$ true, T $>$}}
\begin{DoxyCompactList}\small\item\em specialisation of the \mbox{\hyperlink{structutility_1_1tuple_1_1_static_if}{Static\+If}} when the condition is true \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structutility_1_1tuple_1_1_tuple}{utility\+::tuple\+::\+Tuple$<$ Ts $>$}}
\begin{DoxyCompactList}\small\item\em is a fixed-\/size collection of heterogeneous values \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structutility_1_1tuple_1_1_tuple_3_01_t_00_01_ts_8_8_8_01_4}{utility\+::tuple\+::\+Tuple$<$ T, Ts... $>$}}
\begin{DoxyCompactList}\small\item\em specialisation of the \mbox{\hyperlink{structutility_1_1tuple_1_1_tuple}{Tuple}} class when the tuple has at least one element. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structutility_1_1tuple_1_1_elem_type_holder}{utility\+::tuple\+::\+Elem\+Type\+Holder$<$ size\+\_\+t, class $>$}}
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{structutility_1_1tuple_1_1_elem_type_holder}{Elem\+Type\+Holder}} class is used to specify the types of the elements inside the tuple. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structutility_1_1tuple_1_1_elem_type_holder_3_010_00_01_tuple_3_01_t_00_01_ts_8_8_8_01_4_01_4}{utility\+::tuple\+::\+Elem\+Type\+Holder$<$ 0, Tuple$<$ T, Ts... $>$ $>$}}
\begin{DoxyCompactList}\small\item\em specialisation of the \mbox{\hyperlink{structutility_1_1tuple_1_1_elem_type_holder}{Elem\+Type\+Holder}} class when the number of elements inside the tuple is 1 \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structutility_1_1tuple_1_1_elem_type_holder_3_01k_00_01_tuple_3_01_t_00_01_ts_8_8_8_01_4_01_4}{utility\+::tuple\+::\+Elem\+Type\+Holder$<$ k, Tuple$<$ T, Ts... $>$ $>$}}
\begin{DoxyCompactList}\small\item\em specialisation of the \mbox{\hyperlink{structutility_1_1tuple_1_1_elem_type_holder}{Elem\+Type\+Holder}} class when the number of elements inside the tuple is bigger than 1. It recursively calls itself to detect the type of each element in the tuple \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structutility_1_1tuple_1_1_index_list}{utility\+::tuple\+::\+Index\+List$<$ Is $>$}}
\begin{DoxyCompactList}\small\item\em Creates a list of index from the elements in the tuple. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structutility_1_1tuple_1_1_range_builder}{utility\+::tuple\+::\+Range\+Builder}}
\begin{DoxyCompactList}\small\item\em Collects internal details for generating index ranges \mbox{[}M\+IN, M\+AX) Declare primary template for index range builder. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structutility_1_1tuple_1_1_range_builder_3_01_m_i_n_00_01_m_i_n_00_01_is_8_8_8_01_4}{utility\+::tuple\+::\+Range\+Builder$<$ M\+I\+N, M\+I\+N, Is... $>$}}
\begin{DoxyCompactList}\small\item\em base Step\+: Specialisation of the \mbox{\hyperlink{structutility_1_1tuple_1_1_range_builder}{Range\+Builder}} when the M\+IN==M\+AX. In this case the Is... is \mbox{[}0 to sizeof...(tuple elements)) \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structutility_1_1tuple_1_1_range_builder}{utility\+::tuple\+::\+Range\+Builder}}
\begin{DoxyCompactList}\small\item\em Collects internal details for generating index ranges \mbox{[}M\+IN, M\+AX) Declare primary template for index range builder. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structutility_1_1tuple_1_1_index_range}{utility\+::tuple\+::\+Index\+Range$<$ M\+I\+N, M\+A\+X $>$}}
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{structutility_1_1tuple_1_1_index_range}{Index\+Range}} that returns a \mbox{[}M\+IN, M\+AX) index range. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
 \mbox{\hyperlink{namespaceutility}{utility}}
\item 
 \mbox{\hyperlink{namespaceutility_1_1tuple}{utility\+::tuple}}
\end{DoxyCompactItemize}
\doxysubsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \mbox{\hyperlink{_tensor_sycl_tuple_8h_a34c240717e47583447c4c179db047c69}{T\+E\+R\+M\+I\+N\+A\+T\+E\+\_\+\+C\+O\+N\+D\+S\+\_\+\+T\+U\+P\+L\+E\+\_\+\+G\+ET}}(C\+V\+Qual)
\begin{DoxyCompactList}\small\item\em Extracts the first element from the tuple. K=0 represents the first element of the tuple. The tuple cannot be empty. \end{DoxyCompactList}\item 
\#define \mbox{\hyperlink{_tensor_sycl_tuple_8h_ad6b3b93b7bdda101df81e837a7e0aa8e}{R\+E\+C\+U\+R\+S\+I\+V\+E\+\_\+\+T\+U\+P\+L\+E\+\_\+\+G\+ET}}(C\+V\+Qual)
\begin{DoxyCompactList}\small\item\em Extracts the Kth element from the tuple. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename... Args$>$ }\\Tuple$<$ Args... $>$ \mbox{\hyperlink{namespaceutility_1_1tuple_aa68638ef30be12f1bcc6ef5da635c744}{utility\+::tuple\+::make\+\_\+tuple}} (Args... args)
\begin{DoxyCompactList}\small\item\em Creates a tuple object, deducing the target type from the types of arguments. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename... Args, typename T , size\+\_\+t... I$>$ }\\Tuple$<$ Args..., T $>$ \mbox{\hyperlink{namespaceutility_1_1tuple_a446670118f4f4b05503c4e0b41dae565}{utility\+::tuple\+::append\+\_\+base}} (Tuple$<$ Args... $>$ t, T a, Index\+List$<$ I... $>$)
\begin{DoxyCompactList}\small\item\em unpacking the elements of the input tuple t and creating a new tuple by adding element a at the end of it. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename... Args, typename T $>$ }\\Tuple$<$ Args..., T $>$ \mbox{\hyperlink{namespaceutility_1_1tuple_aeb1d9564d8270778d3b964c1bbc97345}{utility\+::tuple\+::append}} (Tuple$<$ Args... $>$ t, T a)
\begin{DoxyCompactList}\small\item\em the deduction function for \mbox{\hyperlink{namespaceutility_1_1tuple_a446670118f4f4b05503c4e0b41dae565}{append\+\_\+base}} that automatically generate the \mbox{\hyperlink{structutility_1_1tuple_1_1_index_range}{Index\+Range}} \end{DoxyCompactList}\item 
{\footnotesize template$<$typename... Args1, typename... Args2, size\+\_\+t... I1, size\+\_\+t... I2$>$ }\\Tuple$<$ Args1..., Args2... $>$ \mbox{\hyperlink{namespaceutility_1_1tuple_ae5bb1d6f355eb022f06581fb8d02b3a1}{utility\+::tuple\+::append\+\_\+base}} (Tuple$<$ Args1... $>$ t1, Tuple$<$ Args2... $>$ t2, Index\+List$<$ I1... $>$, Index\+List$<$ I2... $>$)
\begin{DoxyCompactList}\small\item\em This is a specialisation of \mbox{\hyperlink{namespaceutility_1_1tuple_a446670118f4f4b05503c4e0b41dae565}{append\+\_\+base}} when we want to concatenate tuple t2 at the end of the tuple t1. Here we unpack both tuples, generate the \mbox{\hyperlink{structutility_1_1tuple_1_1_index_range}{Index\+Range}} for each of them and create an output tuple T that contains both elements of t1 and t2. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename... Args1, typename... Args2$>$ }\\Tuple$<$ Args1..., Args2... $>$ \mbox{\hyperlink{namespaceutility_1_1tuple_a962fd93fb21129491975d3c4807fdad1}{utility\+::tuple\+::append}} (Tuple$<$ Args1... $>$ t1, Tuple$<$ Args2... $>$ t2)
\begin{DoxyCompactList}\small\item\em deduction function for \mbox{\hyperlink{namespaceutility_1_1tuple_a446670118f4f4b05503c4e0b41dae565}{append\+\_\+base}} when we are appending tuple t1 by tuple t2. In this case the \mbox{\hyperlink{structutility_1_1tuple_1_1_index_range}{Index\+Range}} for both tuple are automatically generated. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Macro Definition Documentation}
\mbox{\Hypertarget{_tensor_sycl_tuple_8h_ad6b3b93b7bdda101df81e837a7e0aa8e}\label{_tensor_sycl_tuple_8h_ad6b3b93b7bdda101df81e837a7e0aa8e}} 
\index{TensorSyclTuple.h@{TensorSyclTuple.h}!RECURSIVE\_TUPLE\_GET@{RECURSIVE\_TUPLE\_GET}}
\index{RECURSIVE\_TUPLE\_GET@{RECURSIVE\_TUPLE\_GET}!TensorSyclTuple.h@{TensorSyclTuple.h}}
\doxysubsubsection{\texorpdfstring{RECURSIVE\_TUPLE\_GET}{RECURSIVE\_TUPLE\_GET}}
{\footnotesize\ttfamily \#define R\+E\+C\+U\+R\+S\+I\+V\+E\+\_\+\+T\+U\+P\+L\+E\+\_\+\+G\+ET(\begin{DoxyParamCaption}\item[{}]{C\+V\+Qual }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} k, \textcolor{keyword}{class }T, \textcolor{keyword}{class}... Ts> \(\backslash\)}
\DoxyCodeLine{typename StaticIf<k != 0, CVQual \textcolor{keyword}{typename} ElemTypeHolder<k, Tuple<T, Ts...> >::type \&>::type \(\backslash\)}
\DoxyCodeLine{get(CVQual Tuple<T, Ts...> \&t) \{ \(\backslash\)}
\DoxyCodeLine{  return \mbox{\hyperlink{namespacedetail_a7116703ea757fe9821bf2e903b91c160}{utility::tuple::get}}<k -\/ 1>(t.tail); \(\backslash\)}
\DoxyCodeLine{\}}

\end{DoxyCode}


Extracts the Kth element from the tuple. 

get 
\begin{DoxyTemplParams}{Template Parameters}
{\em K} & is an integer value in \mbox{[}0,sizeof...(Types)). \\
\hline
{\em T} & is the (sizeof...(Types) -\/(K+1)) element in the tuple \\
\hline
{\em Ts...} & are the type of the elements in the tuple. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em t} & is the tuple whose contents to extract \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
typename Elem\+Type\+Holder$<$K, \mbox{\hyperlink{structutility_1_1tuple_1_1_tuple}{Tuple$<$\+Ts...$>$}} $>$\+::type \&$>$\+::type 
\end{DoxyReturn}
\mbox{\Hypertarget{_tensor_sycl_tuple_8h_a34c240717e47583447c4c179db047c69}\label{_tensor_sycl_tuple_8h_a34c240717e47583447c4c179db047c69}} 
\index{TensorSyclTuple.h@{TensorSyclTuple.h}!TERMINATE\_CONDS\_TUPLE\_GET@{TERMINATE\_CONDS\_TUPLE\_GET}}
\index{TERMINATE\_CONDS\_TUPLE\_GET@{TERMINATE\_CONDS\_TUPLE\_GET}!TensorSyclTuple.h@{TensorSyclTuple.h}}
\doxysubsubsection{\texorpdfstring{TERMINATE\_CONDS\_TUPLE\_GET}{TERMINATE\_CONDS\_TUPLE\_GET}}
{\footnotesize\ttfamily \#define T\+E\+R\+M\+I\+N\+A\+T\+E\+\_\+\+C\+O\+N\+D\+S\+\_\+\+T\+U\+P\+L\+E\+\_\+\+G\+ET(\begin{DoxyParamCaption}\item[{}]{C\+V\+Qual }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} k, \textcolor{keyword}{class}... Ts> \(\backslash\)}
\DoxyCodeLine{typename StaticIf<k == 0, CVQual \textcolor{keyword}{typename} ElemTypeHolder<0, Tuple<Ts...> >::type \&>::type \(\backslash\)}
\DoxyCodeLine{get(CVQual Tuple<Ts...> \&t) \{ \(\backslash\)}
\DoxyCodeLine{  static\_assert(\textcolor{keyword}{sizeof}...(Ts)!=0, \textcolor{stringliteral}{"The requseted value is bigger than the size of the tuple"}); \(\backslash\)}
\DoxyCodeLine{  return t.head; \(\backslash\)}
\DoxyCodeLine{\}}

\end{DoxyCode}


Extracts the first element from the tuple. K=0 represents the first element of the tuple. The tuple cannot be empty. 

get 
\begin{DoxyTemplParams}{Template Parameters}
{\em Ts...} & are the type of the elements in the tuple. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em t} & is the tuple whose contents to extract \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
typename Elem\+Type\+Holder$<$0, \mbox{\hyperlink{structutility_1_1tuple_1_1_tuple}{Tuple$<$\+Ts...$>$}} $>$\+::type \&$>$\+::type 
\end{DoxyReturn}
